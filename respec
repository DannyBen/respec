#!/usr/bin/env bash
# This script was generated by bashly 1.2.7 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
respec_usage() {
  printf "respec - RSpec Convenience Wrapper\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec [COMMAND]\n"
  printf "  respec [COMMAND] --help | -h\n"
  printf "  respec --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Run all specs (default)\n" "$(green "all")        "
  printf "  %s   Run specs tagged with :focus\n" "$(green "focus")      "
  printf "  %s   Run specs only on files matching a pattern\n" "$(green "only")       "
  printf "  %s   Run specs except files matching a pattern\n" "$(green "except")     "
  printf "  %s   Run specs that include/exclude certain tags\n" "$(green "tagged")     "
  printf "  %s   Run specs on files modified in the last N minutes\n" "$(green "last")       "
  printf "  %s   Run the last failed specs\n" "$(green "fails")      "
  printf "  %s   Continue from where the last run stopped\n" "$(green "continue")   "
  printf "  %s   Shortcut for 'respec last 2 --watch'\n" "$(green "refactor")   "
  printf "  %s   Delete the status file\n" "$(green "reset")      "
  printf "  %s   Echo completions function\n" "$(green "completions")"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "RESPEC_STATUS_FILE"
    printf "    Where to store the rspec status file\n"
    printf "    %s\n" "Default: spec/status.txt"
    echo

    # :environment_variable.usage
    printf "  %s\n" "RESPEC_HELPER_PATH"
    printf "    The location of the spec_helper.rb file\n"
    printf "    %s\n" "Default: spec/spec_helper.rb"
    echo

  fi
}

# :command.usage
respec_all_usage() {
  if [[ -n $long_usage ]]; then
    printf "respec all\n\n"
    printf "  Run all specs\n  \n  This is the default command, so running \`respec\` is the same as \`respec all\`.\n\n"
  else
    printf "respec all - Run all specs\n\n"
  fi
  printf "Alias: a\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec [all] [OPTIONS]\n"
  printf "  respec all --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--watch, -w"
    printf "    Watch for change and rerun\n"
    printf "    %s\n" "Conflicts: --repeat"
    echo

    # :flag.usage
    printf "  %s\n" "--repeat, -r"
    printf "    Wait for a key press after running and repeat\n"
    printf "    %s\n" "Conflicts: --watch"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
respec_focus_usage() {
  printf "respec focus - Run specs tagged with :focus\n\n"
  printf "Alias: f\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec focus [OPTIONS]\n"
  printf "  respec focus --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--watch, -w"
    printf "    Watch for change and rerun\n"
    printf "    %s\n" "Conflicts: --repeat"
    echo

    # :flag.usage
    printf "  %s\n" "--repeat, -r"
    printf "    Wait for a key press after running and repeat\n"
    printf "    %s\n" "Conflicts: --watch"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
respec_only_usage() {
  printf "respec only - Run specs only on files matching a pattern\n\n"
  printf "Alias: o\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec only SEARCH [OPTIONS]\n"
  printf "  respec only --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--watch, -w"
    printf "    Watch for change and rerun\n"
    printf "    %s\n" "Conflicts: --repeat"
    echo

    # :flag.usage
    printf "  %s\n" "--repeat, -r"
    printf "    Wait for a key press after running and repeat\n"
    printf "    %s\n" "Conflicts: --watch"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "SEARCH"
    printf "    Partial filename\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  # run specs only on paths matching \'*integration*\'\n  $ respec only integration\n"
    echo

  fi
}

# :command.usage
respec_except_usage() {
  printf "respec except - Run specs except files matching a pattern\n\n"
  printf "Alias: e, ex\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec except SEARCH [OPTIONS]\n"
  printf "  respec except --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--watch, -w"
    printf "    Watch for change and rerun\n"
    printf "    %s\n" "Conflicts: --repeat"
    echo

    # :flag.usage
    printf "  %s\n" "--repeat, -r"
    printf "    Wait for a key press after running and repeat\n"
    printf "    %s\n" "Conflicts: --watch"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "SEARCH"
    printf "    Partial filename\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  # run specs only on paths not matching \'*examples*\'\n  $ respec except examples\n"
    echo

  fi
}

# :command.usage
respec_tagged_usage() {
  printf "respec tagged - Run specs that include/exclude certain tags\n\n"
  printf "Alias: t, tag, tags\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec tagged TAG... [OPTIONS]\n"
  printf "  respec tagged --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--watch, -w"
    printf "    Watch for change and rerun\n"
    printf "    %s\n" "Conflicts: --repeat"
    echo

    # :flag.usage
    printf "  %s\n" "--repeat, -r"
    printf "    Wait for a key press after running and repeat\n"
    printf "    %s\n" "Conflicts: --watch"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "TAG..."
    printf "    One or more tag names. Prefix with ~ to negate.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  # run specs tagged :production and not tagged :slow\n  $ respec tagged production ~slow\n"
    echo

  fi
}

# :command.usage
respec_last_usage() {
  printf "respec last - Run specs on files modified in the last N minutes\n\n"
  printf "Alias: l\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec last [MIN] [OPTIONS]\n"
  printf "  respec last --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--watch, -w"
    printf "    Watch for change and rerun\n"
    printf "    %s\n" "Conflicts: --repeat"
    echo

    # :flag.usage
    printf "  %s\n" "--repeat, -r"
    printf "    Wait for a key press after running and repeat\n"
    printf "    %s\n" "Conflicts: --watch"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "MIN"
    printf "    Number of minutes\n"
    printf "    %s\n" "Default: 10"
    echo

  fi
}

# :command.usage
respec_fails_usage() {
  printf "respec fails - Run the last failed specs\n\n"
  printf "Alias: failures\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec fails [OPTIONS]\n"
  printf "  respec fails --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--watch, -w"
    printf "    Watch for change and rerun\n"
    printf "    %s\n" "Conflicts: --repeat"
    echo

    # :flag.usage
    printf "  %s\n" "--repeat, -r"
    printf "    Wait for a key press after running and repeat\n"
    printf "    %s\n" "Conflicts: --watch"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
respec_continue_usage() {
  printf "respec continue - Continue from where the last run stopped\n\n"
  printf "Alias: c, cont\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec continue [OPTIONS]\n"
  printf "  respec continue --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--watch, -w"
    printf "    Watch for change and rerun\n"
    printf "    %s\n" "Conflicts: --repeat"
    echo

    # :flag.usage
    printf "  %s\n" "--repeat, -r"
    printf "    Wait for a key press after running and repeat\n"
    printf "    %s\n" "Conflicts: --watch"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
respec_refactor_usage() {
  printf "respec refactor - Shortcut for 'respec last 2 --watch'\n\n"
  printf "Alias: r\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec refactor\n"
  printf "  respec refactor --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
respec_reset_usage() {
  printf "respec reset - Delete the status file\n\n"

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec reset\n"
  printf "  respec reset --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
respec_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "respec completions\n\n"
    printf "  Echo completions function\n  \n  Intended to be used with: eval \"\$(respec completions)\"\n\n"
  else
    printf "respec completions - Echo completions function\n\n"
  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  respec completions\n"
  printf "  respec completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.user_lib
# src/lib/banner.sh
banner() {
  magenta "respec: $*"
}

# src/lib/bell.sh
bell() {
  printf '\a'
}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
black() { print_in_color "\e[30m" "$*"; }
white() { print_in_color "\e[37m" "$*"; }

bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }

red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
black_bold() { print_in_color "\e[1;30m" "$*"; }
white_bold() { print_in_color "\e[1;37m" "$*"; }

red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }
black_underlined() { print_in_color "\e[4;30m" "$*"; }
white_underlined() { print_in_color "\e[4;37m" "$*"; }

# src/lib/fail.sh
fail() {
  red "$*"
  exit 1
}

# src/lib/filters/filter_spec_helper_config.sh
filter_spec_helper_config() {
  regex="example_status_persistence_file_path.*=.*$RESPEC_STATUS_FILE"

  if [[ ! -f "$RESPEC_HELPER_PATH" ]]; then
    echo "Unable to find spec_helper ($RESPEC_HELPER_PATH)"
    return
  fi

  if ! grep -q "$regex" "$RESPEC_HELPER_PATH"; then
    echo "This command requires configuration in these files:"
    echo
    magenta "# $RESPEC_HELPER_PATH"
    echo "RSpec.configure do |config|"
    echo "  config.example_status_persistence_file_path = '$RESPEC_STATUS_FILE'"
    echo "end"
    echo
    magenta "# .gitignore"
    echo "$RESPEC_STATUS_FILE"
    return
  fi
}

# src/lib/reset_status.sh
reset_status() {
  rm -f "$RESPEC_STATUS_FILE"
}

# src/lib/run_repeat.sh
run_repeat() {
  : "${CLEAR:=clear}"

  while true; do
    # Run in a clear screen
    $CLEAR
    "$@" || true
    echo

    # Wait for key press
    read -n 1 -s -r -p "Press any key to rerun or 'q' to quit..." key

    # Flush the input buffer
    while read -r -n 1 -s -t 0.1; do :; done

    # Quit on q
    if [ "$key" = 'q' ]; then
      echo
      break
    fi
  done
}

# src/lib/run_rspec.sh
run_rspec() {
  set +e
  bundle exec rspec "$@"
  exit_code=$?
  set -e

  [[ $exit_code -ne 0 ]] && bell
  return $exit_code
}

# src/lib/run_watch.sh
run_watch() {
  filewatcher --immediate '**/*.rb' "clear ; $*"
}

# src/lib/send_completions.sh
send_completions() {
  echo $'# respec completion                                        -*- shell-script -*-'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $''
  echo $'_respec_completions_filter() {'
  echo $'  local words="$1"'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local result=()'
  echo $''
  echo $'  if [[ "${cur:0:1}" == "-" ]]; then'
  echo $'    echo "$words"'
  echo $''
  echo $'  else'
  echo $'    for word in $words; do'
  echo $'      [[ "${word:0:1}" != "-" ]] && result+=("$word")'
  echo $'    done'
  echo $''
  echo $'    echo "${result[*]}"'
  echo $''
  echo $'  fi'
  echo $'}'
  echo $''
  echo $'_respec_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local compwords=("${COMP_WORDS[@]:1:$COMP_CWORD-1}")'
  echo $'  local compline="${compwords[*]}"'
  echo $''
  echo $'  case "$compline" in'
  echo $'    \'completions\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'refactor\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'continue\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'failures\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'except\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'tagged\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'reset\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'focus\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'fails\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'cont\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'only\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'last\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'tags\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'tag\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'all\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'ex\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'t\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'l\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'e\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'o\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'c\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'f\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'a\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --repeat --watch -h -r -w")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    \'r\'*)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help -h")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'    *)'
  echo $'      while read -r; do COMPREPLY+=("$REPLY"); done < <(compgen -W "$(_respec_completions_filter "--help --version -h -v a all c completions cont continue e ex except f fails failures focus l last o only r refactor reset t tag tagged tags")" -- "$cur")'
  echo $'      ;;'
  echo $''
  echo $'  esac'
  echo $'} &&'
  echo $'  complete -F _respec_completions respec'
  echo $''
  echo $'# ex: filetype=sh'
}

# src/lib/validations/validate_integer.sh
validate_integer() {
  [[ "$1" =~ ^[0-9]+$ ]] || echo "must be an integer"
}

# :command.command_functions
# :command.function
respec_all_command() {

  # src/all_command.sh
  watch="${args[--watch]}"
  repeat="${args[--repeat]}"

  if [[ $watch ]]; then
    run_watch "respec all"
  elif [[ $repeat ]]; then
    run_repeat respec all
  else
    reset_status
    banner "all"
    run_rspec
  fi

}

# :command.function
respec_focus_command() {

  # src/focus_command.sh
  watch="${args[--watch]}"
  repeat="${args[--repeat]}"

  if [[ $watch ]]; then
    run_watch "respec focus"
  elif [[ $repeat ]]; then
    run_repeat respec focus
  else
    banner "focus"
    run_rspec --tag focus
  fi

}

# :command.function
respec_only_command() {

  # src/only_command.sh
  search="${args[search]}"
  watch="${args[--watch]}"
  repeat="${args[--repeat]}"

  if [[ $watch ]]; then
    run_watch "respec only $search"
  elif [[ $repeat ]]; then
    run_repeat respec only "$search"
  else
    banner "only *$search*"
    reset_status

    # shellcheck disable=SC2046
    run_rspec $( (find . -name '*_spec.rb' -path "*$search*" | grep .) || echo "-tnothing")
  fi
}

# :command.function
respec_except_command() {

  # src/except_command.sh
  search="${args[search]}"
  watch="${args[--watch]}"
  repeat="${args[--repeat]}"

  if [[ $watch ]]; then
    run_watch "respec except $search"
  elif [[ $repeat ]]; then
    run_repeat respec except "$search"
  else
    banner "except *$search*"
    reset_status

    # shellcheck disable=SC2046
    run_rspec $( (find . -name '*_spec.rb' -not -path "*$search*" | grep .) || echo "-tnothing")
  fi
}

# :command.function
respec_tagged_command() {

  # src/tagged_command.sh
  watch="${args[--watch]}"
  repeat="${args[--repeat]}"
  eval "tags=(${args[tag]})"

  # Clean up the tags array by replacing \\~ with \~
  for i in "${!tags[@]}"; do
    tags[i]="${tags[$i]//\\~/\~}"
  done

  # Zip the tags array with --tag prefix for each element
  for tag in "${tags[@]}"; do
    rspec_args+=(--tag "$tag")
  done

  if [[ $watch ]]; then
    run_watch respec tagged "${tags[@]}"
  elif [[ $repeat ]]; then
    run_repeat respec tagged "${tags[@]}"
  else
    banner "tagged ${tags[*]}"
    reset_status

    run_rspec "${rspec_args[@]}"
  fi

}

# :command.function
respec_last_command() {

  # src/last_command.sh
  min="${args[min]}"

  watch="${args[--watch]}"
  repeat="${args[--repeat]}"

  if [[ $watch ]]; then
    run_watch "respec last $min"
  elif [[ $repeat ]]; then
    run_repeat respec last "$min"
  else
    banner "last $min minutes"
    reset_status

    # shellcheck disable=SC2046
    run_rspec $( (find . -name '*_spec.rb' -mmin -"$min" | grep .) || echo "-tnothing")
  fi

}

# :command.function
respec_fails_command() {

  # src/fails_command.sh
  watch="${args[--watch]}"
  repeat="${args[--repeat]}"

  if [[ $watch ]]; then
    run_watch "respec fails"
  elif [[ $repeat ]]; then
    run_repeat respec fails
  else
    banner "failed specs"
    run_rspec --next-failure
  fi

}

# :command.function
respec_continue_command() {

  # src/continue_command.sh
  watch="${args[--watch]}"
  repeat="${args[--repeat]}"

  if [[ $watch ]]; then
    run_watch "respec continue"
  elif [[ $repeat ]]; then
    run_repeat respec continue
  else
    banner "continue"
    run_rspec --tag ~last_run_status:passed
  fi

}

# :command.function
respec_refactor_command() {

  # src/refactor_command.sh
  run_watch "respec last 2"

}

# :command.function
respec_reset_command() {

  # src/reset_command.sh
  banner "delete status file"
  if [[ -f "$RESPEC_STATUS_FILE" ]]; then
    reset_status
    echo "deleted $RESPEC_STATUS_FILE"
  else
    echo "file not found: $RESPEC_STATUS_FILE"
  fi

}

# :command.function
respec_completions_command() {

  # src/completions_command.sh
  send_completions
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        respec_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export RESPEC_STATUS_FILE="${RESPEC_STATUS_FILE:-spec/status.txt}"
  export RESPEC_HELPER_PATH="${RESPEC_HELPER_PATH:-spec/spec_helper.rb}"

  # :command.command_filter
  action=${1:-}

  case $action in

    all | a)
      action="all"
      shift
      respec_all_parse_requirements "$@"
      shift $#
      ;;

    focus | f)
      action="focus"
      shift
      respec_focus_parse_requirements "$@"
      shift $#
      ;;

    only | o)
      action="only"
      shift
      respec_only_parse_requirements "$@"
      shift $#
      ;;

    except | e | ex)
      action="except"
      shift
      respec_except_parse_requirements "$@"
      shift $#
      ;;

    tagged | t | tag | tags)
      action="tagged"
      shift
      respec_tagged_parse_requirements "$@"
      shift $#
      ;;

    last | l)
      action="last"
      shift
      respec_last_parse_requirements "$@"
      shift $#
      ;;

    fails | failures)
      action="fails"
      shift
      respec_fails_parse_requirements "$@"
      shift $#
      ;;

    continue | c | cont)
      action="continue"
      shift
      respec_continue_parse_requirements "$@"
      shift $#
      ;;

    refactor | r)
      action="refactor"
      shift
      respec_refactor_parse_requirements "$@"
      shift $#
      ;;

    reset)
      action="reset"
      shift
      respec_reset_parse_requirements "$@"
      shift $#
      ;;

    completions)
      action="completions"
      shift
      respec_completions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    *)
      action="all"
      respec_all_parse_requirements "$@"
      shift $#
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
respec_all_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        respec_all_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v rspec >/dev/null 2>&1; then
    printf "missing dependency: rspec\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install rspec)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v bundler >/dev/null 2>&1; then
    printf "missing dependency: bundler\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install bundler)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v filewatcher >/dev/null 2>&1; then
    printf "missing dependency: filewatcher\n" >&2
    printf "%s\n\n" "Install with $(magenta gem install filewatcher-cli)" >&2
    missing_deps=1
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="all"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --watch | -w)
        # :flag.conflicts
        if [[ -n "${args['--repeat']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--repeat" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--watch']=1
        shift
        ;;

      # :flag.case
      --repeat | -r)
        # :flag.conflicts
        if [[ -n "${args['--watch']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--watch" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--repeat']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
respec_focus_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        respec_focus_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v rspec >/dev/null 2>&1; then
    printf "missing dependency: rspec\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install rspec)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v bundler >/dev/null 2>&1; then
    printf "missing dependency: bundler\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install bundler)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v filewatcher >/dev/null 2>&1; then
    printf "missing dependency: filewatcher\n" >&2
    printf "%s\n\n" "Install with $(magenta gem install filewatcher-cli)" >&2
    missing_deps=1
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="focus"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --watch | -w)
        # :flag.conflicts
        if [[ -n "${args['--repeat']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--repeat" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--watch']=1
        shift
        ;;

      # :flag.case
      --repeat | -r)
        # :flag.conflicts
        if [[ -n "${args['--watch']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--watch" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--repeat']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
respec_only_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        respec_only_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v rspec >/dev/null 2>&1; then
    printf "missing dependency: rspec\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install rspec)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v bundler >/dev/null 2>&1; then
    printf "missing dependency: bundler\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install bundler)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v filewatcher >/dev/null 2>&1; then
    printf "missing dependency: filewatcher\n" >&2
    printf "%s\n\n" "Install with $(magenta gem install filewatcher-cli)" >&2
    missing_deps=1
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="only"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --watch | -w)
        # :flag.conflicts
        if [[ -n "${args['--repeat']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--repeat" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--watch']=1
        shift
        ;;

      # :flag.case
      --repeat | -r)
        # :flag.conflicts
        if [[ -n "${args['--watch']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--watch" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--repeat']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['search']+x} ]]; then
          args['search']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['search']+x} ]]; then
    printf "missing required argument: SEARCH\nusage: respec only SEARCH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
respec_except_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        respec_except_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v rspec >/dev/null 2>&1; then
    printf "missing dependency: rspec\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install rspec)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v bundler >/dev/null 2>&1; then
    printf "missing dependency: bundler\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install bundler)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v filewatcher >/dev/null 2>&1; then
    printf "missing dependency: filewatcher\n" >&2
    printf "%s\n\n" "Install with $(magenta gem install filewatcher-cli)" >&2
    missing_deps=1
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="except"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --watch | -w)
        # :flag.conflicts
        if [[ -n "${args['--repeat']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--repeat" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--watch']=1
        shift
        ;;

      # :flag.case
      --repeat | -r)
        # :flag.conflicts
        if [[ -n "${args['--watch']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--watch" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--repeat']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['search']+x} ]]; then
          args['search']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['search']+x} ]]; then
    printf "missing required argument: SEARCH\nusage: respec except SEARCH [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
respec_tagged_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        respec_tagged_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v rspec >/dev/null 2>&1; then
    printf "missing dependency: rspec\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install rspec)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v bundler >/dev/null 2>&1; then
    printf "missing dependency: bundler\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install bundler)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v filewatcher >/dev/null 2>&1; then
    printf "missing dependency: filewatcher\n" >&2
    printf "%s\n\n" "Install with $(magenta gem install filewatcher-cli)" >&2
    missing_deps=1
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="tagged"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --watch | -w)
        # :flag.conflicts
        if [[ -n "${args['--repeat']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--repeat" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--watch']=1
        shift
        ;;

      # :flag.case
      --repeat | -r)
        # :flag.conflicts
        if [[ -n "${args['--watch']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--watch" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--repeat']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_repeatable
        # :argument.case_repeatable
        escaped="$(printf '%q' "$1")"
        if [[ -z ${args['tag']+x} ]]; then
          args['tag']="$escaped"
        else
          args['tag']="${args['tag']} $escaped"

        fi
        shift

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tag']+x} ]]; then
    printf "missing required argument: TAG\nusage: respec tagged TAG... [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
respec_last_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        respec_last_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v rspec >/dev/null 2>&1; then
    printf "missing dependency: rspec\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install rspec)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v bundler >/dev/null 2>&1; then
    printf "missing dependency: bundler\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install bundler)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v filewatcher >/dev/null 2>&1; then
    printf "missing dependency: filewatcher\n" >&2
    printf "%s\n\n" "Install with $(magenta gem install filewatcher-cli)" >&2
    missing_deps=1
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="last"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --watch | -w)
        # :flag.conflicts
        if [[ -n "${args['--repeat']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--repeat" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--watch']=1
        shift
        ;;

      # :flag.case
      --repeat | -r)
        # :flag.conflicts
        if [[ -n "${args['--watch']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--watch" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--repeat']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['min']+x} ]]; then
          args['min']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['min']:-} ]] || args['min']="10"

  # :command.validations
  # :argument.validations
  if [[ -v args['min'] && -n $(validate_integer "${args['min']:-}") ]]; then
    printf "validation error in %s:\n%s\n" "MIN" "$(validate_integer "${args['min']:-}")" >&2
    exit 1
  fi

}

# :command.parse_requirements
respec_fails_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        respec_fails_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v rspec >/dev/null 2>&1; then
    printf "missing dependency: rspec\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install rspec)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v bundler >/dev/null 2>&1; then
    printf "missing dependency: bundler\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install bundler)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v filewatcher >/dev/null 2>&1; then
    printf "missing dependency: filewatcher\n" >&2
    printf "%s\n\n" "Install with $(magenta gem install filewatcher-cli)" >&2
    missing_deps=1
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="fails"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --watch | -w)
        # :flag.conflicts
        if [[ -n "${args['--repeat']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--repeat" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--watch']=1
        shift
        ;;

      # :flag.case
      --repeat | -r)
        # :flag.conflicts
        if [[ -n "${args['--watch']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--watch" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--repeat']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_spec_helper_config)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
respec_continue_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        respec_continue_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v rspec >/dev/null 2>&1; then
    printf "missing dependency: rspec\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install rspec)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v bundler >/dev/null 2>&1; then
    printf "missing dependency: bundler\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install bundler)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v filewatcher >/dev/null 2>&1; then
    printf "missing dependency: filewatcher\n" >&2
    printf "%s\n\n" "Install with $(magenta gem install filewatcher-cli)" >&2
    missing_deps=1
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="continue"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --watch | -w)
        # :flag.conflicts
        if [[ -n "${args['--repeat']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--repeat" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--watch']=1
        shift
        ;;

      # :flag.case
      --repeat | -r)
        # :flag.conflicts
        if [[ -n "${args['--watch']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--watch" >&2
          exit 1
        fi

        # :flag.case_no_arg
        args['--repeat']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_spec_helper_config)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
respec_refactor_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        respec_refactor_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v rspec >/dev/null 2>&1; then
    printf "missing dependency: rspec\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install rspec)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v bundler >/dev/null 2>&1; then
    printf "missing dependency: bundler\n" >&2
    printf "%s\n\n" "Install using $(magenta gem install bundler)" >&2
    missing_deps=1
  fi

  # :dependency.filter
  if ! command -v filewatcher >/dev/null 2>&1; then
    printf "missing dependency: filewatcher\n" >&2
    printf "%s\n\n" "Install with $(magenta gem install filewatcher-cli)" >&2
    missing_deps=1
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action="refactor"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
respec_reset_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        respec_reset_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="reset"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.user_filter
  filter_error=$(filter_spec_helper_config)
  if [[ -n $filter_error ]]; then
    echo "$filter_error" >&2
    exit 1
  fi

}

# :command.parse_requirements
respec_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        respec_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.1.11"
  long_usage=''
  set -e

  # :command.environment_variables_default
  export RESPEC_STATUS_FILE="${RESPEC_STATUS_FILE:-spec/status.txt}"
  export RESPEC_HELPER_PATH="${RESPEC_HELPER_PATH:-spec/spec_helper.rb}"

  # :command.globals
  declare -g -A args=()
  declare -g -a input=()

}

# :command.run
run() {
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "all") respec_all_command ;;
    "focus") respec_focus_command ;;
    "only") respec_only_command ;;
    "except") respec_except_command ;;
    "tagged") respec_tagged_command ;;
    "last") respec_last_command ;;
    "fails") respec_fails_command ;;
    "continue") respec_continue_command ;;
    "refactor") respec_refactor_command ;;
    "reset") respec_reset_command ;;
    "completions") respec_completions_command ;;
  esac
}

initialize
run "$@"
